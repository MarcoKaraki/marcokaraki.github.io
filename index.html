<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <script src="https://cesiumjs.org/releases/1.60/Build/Cesium/Cesium.js"></script>
  <link href="https://cesiumjs.org/releases/1.60/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
</head>
<body>
  <div id="cesiumContainer" ></div>
  <script>
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI3MjE5YjNjNi0yN2ExLTRjMjEtYWE5Ni0xYTMyYWRiY2FiMzciLCJpZCI6MTQxNDcsInNjb3BlcyI6WyJhc3IiLCJnYyJdLCJpYXQiOjE1NjQ4NjQzMzN9.uDAj2Bp5hr18sQEDoXMKzFH_2OmTBssvNfSMNASnu4I';

    var viewer = new Cesium.Viewer('cesiumContainer', {
      infoBox: false, //Disable InfoBox widget
      selectionIndicator: false, //Disable selection indicator
      shouldAnimate: true, // Enable animations
      animation: false,
      //timeline: false,
      homeButton: false,
      sceneModePicker: false,
      terrainProvider: Cesium.createWorldTerrain(),
      scene3DOnly: true
    });
    
    //Enable lighting based on sun/moon positions
    viewer.scene.globe.enableLighting = true;
    
    //Enable depth testing so things behind the terrain disappear.
    viewer.scene.globe.depthTestAgainstTerrain = true;

    //Set bounds of our simulation time
    var start = Cesium.JulianDate.fromDate(new Date());
    var stop = Cesium.JulianDate.addSeconds(start, 360, new Cesium.JulianDate());
    
    //Set timeline to simulation bounds if the timeline is enabled
    viewer.timeline.zoomTo(start, stop);

    //Make sure viewer is at the desired time.
    viewer.clock.startTime = start.clone();
    viewer.clock.stopTime = stop.clone();
    viewer.clock.currentTime = start.clone();
    viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP; //Loop at the end
    viewer.clock.multiplier = 10;


    //Generate a random circular pattern with varying heights.
    function computeCirclularFlight(lon, lat, radius) {
        var property = new Cesium.SampledPositionProperty();
        for (var i = 0; i <= 360; i += 45) {
            var radians = Cesium.Math.toRadians(i);
            var time = Cesium.JulianDate.addSeconds(start, i, new Cesium.JulianDate());
            var position = Cesium.Cartesian3.fromDegrees(lon + (radius * 1.5 * Math.cos(radians)), lat + (radius * Math.sin(radians)), Cesium.Math.nextRandomNumber() * 500 + 1750);
            property.addSample(time, position);

            //Also create a point for each sample we generate.
            viewer.entities.add({
                position : position,
                point : {
                    pixelSize : 8,
                    color : Cesium.Color.TRANSPARENT,
                    outlineColor : Cesium.Color.YELLOW,
                    outlineWidth : 3
                }
            });
        }
        return property;
    }

    //Compute the entity position property.
    var position = computeCirclularFlight(-112.110693, 36.0994841, 0.03);
    
    //Actually create the entity
    var entity = viewer.entities.add({

        //Set the entity availability to the same interval as the simulation time.
        availability : new Cesium.TimeIntervalCollection([new Cesium.TimeInterval({
            start : start,
            stop : stop
        })]),

        //Use our computed positions
        position : position,

        //Automatically compute orientation based on position movement.
        orientation : new Cesium.VelocityOrientationProperty(position),

        //Load the Cesium plane model to represent the entity
        model : {
            uri : 'https://a.uguu.se/CXPCQ8PRPOy5_40e0f653-bfd2-4809-94ab-cbff323d8f4c_scene.gltf',
            minimumPixelSize : 64
        },

        //Show the path as a pink line sampled in 1 second increments.
        path : {
            resolution : 1,
            material : new Cesium.PolylineGlowMaterialProperty({
                glowPower : 0.1,
                color : Cesium.Color.YELLOW
            }),
            width : 10
        }
    });

    //Add button to track the entity as it moves
    viewer.trackedEntity = entity;

  </script>
</body>
</html>